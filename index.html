<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Student Performance Analysis</title>
    <!-- Include D3.js library -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- Include a Google Font for better typography -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,500,700&display=swap">
    <style>
        /* Global Styling */
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f7f9fc;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 40px;
            font-weight: 500;
        }
        h2 {
            font-size: 24px;
            color: #2c3e50;
            margin-bottom: 10px;
            font-weight: 500;
        }
        .controls, .chart-controls {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .controls select, .chart-controls select {
            margin-right: 15px;
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
        }
        svg {
            border: 1px solid #e1e4e8;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 40px;
        }
        .axis-label {
            font-size: 14px;
            fill: #333;
            font-weight: 500;
        }
        .chart-title {
            font-size: 18px;
            font-weight: 500;
            fill: #2c3e50;
        }
        .legend text {
            font-size: 12px;
            fill: #333;
        }
        .legend rect {
            stroke: #ccc;
            stroke-width: 1px;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 6px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border-radius: 4px;
            pointer-events: none;
        }
        .legend g {
            transition: opacity 0.2s;
        }
        .legend g:hover {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Student Performance Analysis Dashboard</h1>

    <!-- Global Controls for all charts -->
    <div class="controls">
        <label for="xAxis">Select X-Axis Metric:</label>
        <select id="xAxis">
            <option value="Previous_Scores">Previous Scores</option>
            <option value="Hours_Studied">Hours Studied</option>
            <option value="Tutoring_Sessions">Tutoring Sessions</option>
            <option value="Sleep_Hours">Sleep Hours</option>
        </select>

        <label for="genderFilter">Filter by Gender:</label>
        <select id="genderFilter">
            <option value="">All Genders</option>
            <option value="Male">Male</option>
            <option value="Female">Female</option>
        </select>
    </div>

    <!-- Chart 1: Personal Characteristics -->
    <h2>Personal Characteristics</h2>
    <div class="chart-controls" id="controls-personal">
        <label for="variableSelector-personal">Color by:</label>
        <select class="variableSelector" id="variableSelector-personal" data-chart="personal">
            <option value="">Select Variable...</option>
        </select>
    </div>
    <div id="chart-personal"></div>

    <!-- Chart 2: Family & Socioeconomic -->
    <h2>Family & Socioeconomic</h2>
    <div class="chart-controls" id="controls-family">
        <label for="variableSelector-family">Color by:</label>
        <select class="variableSelector" id="variableSelector-family" data-chart="family">
            <option value="">Select Variable...</option>
            <!-- Options will be populated dynamically -->
        </select>
    </div>
    <div id="chart-family"></div>

    <!-- Chart 3: School Environment -->
    <h2>School Environment</h2>
    <div class="chart-controls" id="controls-school">
        <label for="variableSelector-school">Color by:</label>
        <select class="variableSelector" id="variableSelector-school" data-chart="school">
            <option value="">Select Variable...</option>
            <!-- Options will be populated dynamically -->
        </select>
    </div>
    <div id="chart-school"></div>

    <!-- Tooltip Div -->
    <div class="tooltip" style="opacity: 0;"></div>

    <script>
        const width = 960, height = 500, margin = { top: 80, right: 150, bottom: 60, left: 60 };

        // Mapping of categories to variables
        const categoryVariables = {
            "Personal Characteristics": [
                { value: "Motivation_Level", text: "Motivation Level" },
                { value: "Learning_Disabilities", text: "Learning Disabilities" },
                { value: "Physical_Activity", text: "Physical Activity" },
                { value: "Extracurricular_Activities", text: "Extracurricular Activities" }
            ],
            "Family & Socioeconomic": [
                { value: "Family_Income", text: "Family Income" },
                { value: "Parental_Education_Level", text: "Parental Education Level" },
                { value: "Parental_Involvement", text: "Parental Involvement" },
                { value: "Internet_Access", text: "Internet Access" },
                { value: "Access_to_Resources", text: "Access to Resources" }
            ],
            "School Environment": [
                { value: "School_Type", text: "School Type" },
                { value: "Teacher_Quality", text: "Teacher Quality" },
                { value: "Peer_Influence", text: "Peer Influence" }
            ]
        };

        const charts = [
            {
                id: "chart-personal",
                title: "Personal Characteristics",
                controlsId: "controls-personal",
                category: "Personal Characteristics"
            },
            {
                id: "chart-family",
                title: "Family & Socioeconomic",
                controlsId: "controls-family",
                category: "Family & Socioeconomic"
            },
            {
                id: "chart-school",
                title: "School Environment",
                controlsId: "controls-school",
                category: "School Environment"
            }
        ];

        const createSVG = (id) => d3.select(`#${id}`)
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        //  Arrays to store chart-specific variables
        const svgs = [];
        const xScales = [];
        const yScales = [];

        d3.csv("StudentPerformanceFactors.csv").then(data => {
            // Convert numeric fields
            data.forEach(d => {
                d.Hours_Studied = +d.Hours_Studied;
                d.Sleep_Hours = +d.Sleep_Hours;
                d.Previous_Scores = +d.Previous_Scores;
                d.Tutoring_Sessions = +d.Tutoring_Sessions;
                d.Exam_Score = +d.Exam_Score;
                d.Physical_Activity = +d.Physical_Activity;
            });

            // Randomly sample 50% of the data
            // const sampleSize = Math.floor(data.length * 0.5);
            // data = data
            //     .sort(() => Math.random() - 0.5)  // Shuffle the array
            //     .slice(0, sampleSize);            // Take first half

            // Initialize charts and store references
            charts.forEach((chart, index) => {
                const svg = createSVG(chart.id);
                svgs.push(svg);

                const xScale = d3.scaleLinear().range([margin.left, width - margin.right]);
                const yScale = d3.scaleLinear().range([height - margin.bottom, margin.top]);

                xScales.push(xScale);
                yScales.push(yScale);

                // Populate variable selector options for each chart
                const variables = categoryVariables[chart.category];

                const variableSelect = d3.select(`#${chart.controlsId}`).select(".variableSelector");

                if (variables) {
                    variables.forEach(variable => {
                        variableSelect.append("option")
                            .attr("value", variable.value)
                            .text(variable.text);
                    });
                } else {
                    console.error(`No variables found for category "${chart.category}".`);
                }
            });

            // Tooltip
            const tooltip = d3.select(".tooltip");

            // Define all categorical variables
            const categoricalVariables = [
                "Gender", 
                "School_Type",
                "Parental_Education_Level",
                "Motivation_Level",      // Low, Medium, High
                "Physical_Activity",     // 0-6 levels
                "Teacher_Quality",       // Low, Medium, High
                "Family_Income",        // Low, Medium, High
                "Peer_Influence",       // Negative, Neutral, Positive
                "Access_to_Resources",  // Low, Medium, High
                "Parental_Involvement", // Low, Medium, High
                "Learning_Disabilities", // Yes, No
                "Internet_Access",      // Yes, No
                "Extracurricular_Activities" // Yes, No
            ];

            // Define updateVis function
            const updateVis = () => {
                const xMetric = d3.select("#xAxis").property("value");
                const genderFilter = d3.select("#genderFilter").property("value");

                let filteredData = data;
                if (genderFilter) filteredData = filteredData.filter(d => d.Gender === genderFilter);

                charts.forEach((chart, index) => {
                    const svg = svgs[index];
                    const xScale = xScales[index];
                    const yScale = yScales[index];

                    const controls = d3.select(`#${chart.controlsId}`);
                    const variable = controls.select(".variableSelector").property("value");

                    // Proceed only if a variable is selected
                    if (!variable) {
                        svg.selectAll("*").remove();
                        return;
                    }

                    let chartData = filteredData;

                    // Exclude data points with undefined values
                    chartData = chartData.filter(d => d[variable] !== undefined && d[variable] !== "" && d[xMetric] !== undefined && d[xMetric] !== "");

                    // Define rounding factor based on the metric
                    let roundingFactor;
                    switch(xMetric) {
                        case 'Sleep_Hours':
                        case 'Hours_Studied':
                            roundingFactor = 0.5;
                            break;
                        case 'Tutoring_Sessions':
                            roundingFactor = 1;
                            break;
                        case 'Previous_Scores':
                            roundingFactor = 5;
                            break;
                        default:
                            roundingFactor = 1;
                    }

                    // Update scales
                    xScale.domain([
                        Math.floor(d3.min(chartData, d => d[xMetric]) / roundingFactor) * roundingFactor,
                        Math.ceil(d3.max(chartData, d => d[xMetric]) / roundingFactor) * roundingFactor
                    ]);
                    yScale.domain([
                        Math.floor(d3.min(chartData, d => d.Exam_Score) / 5) * 5,
                        80  // Set fixed maximum to 80
                    ]);

                    svg.selectAll("*").remove();

                    // Get categories and set up color scale
                    let categories = [...new Set(chartData.map(d => d[variable]))].filter(v => v !== undefined && v !== "");
                    
                    // Custom sorting for specific categorical variables
                    const educationOrder = ["High School", "College", "Postgraduate"];
                    const levelOrder = ["Low", "Medium", "High"];
                    const influenceOrder = ["Negative", "Neutral", "Positive"];

                    // Sort categories based on variable type
                    categories.sort((a, b) => {
                        // For education levels
                        if (variable === "Parental_Education_Level") {
                            return educationOrder.indexOf(a) - educationOrder.indexOf(b);
                        }
                        // For variables with Low/Medium/High values
                        else if (["Motivation_Level", "Teacher_Quality", "Family_Income", 
                                "Access_to_Resources", "Parental_Involvement"].includes(variable)) {
                            return levelOrder.indexOf(a) - levelOrder.indexOf(b);
                        }
                        // For Peer Influence
                        else if (variable === "Peer_Influence") {
                            return influenceOrder.indexOf(a) - influenceOrder.indexOf(b);
                        }
                        // For numeric values
                        else if (!isNaN(a) && !isNaN(b)) {
                            return Number(a) - Number(b);
                        }
                        // Default alphabetical sorting for other categories
                        return a.localeCompare(b);
                    });

                    const colorScale = d3.scaleOrdinal()
                        .domain(categories)
                        .range(categories.map((_, i) => d3.interpolateBlues(0.2 + (i * 1 / categories.length))));

                    // Calculate median lines
                    const medianLines = categories.map(category => {
                        const categoryData = chartData.filter(d => d[variable] === category);
                        
                        const binSize = 2;
                        const groupedByX = d3.group(categoryData, d => Math.floor(d[xMetric] / binSize) * binSize);
                        
                        const points = Array.from(groupedByX, ([x, values]) => ({
                            x: +x,
                            y: d3.median(values, d => d.Exam_Score),
                            category: category
                        })).filter(point => !isNaN(point.y));

                        points.sort((a, b) => a.x - b.x);

                        // Apply moving average smoothing
                        const windowSize = 2;
                        const smoothedPoints = points.map((point, i) => {
                            const window = points.slice(
                                Math.max(0, i - windowSize),
                                Math.min(points.length, i + windowSize + 1)
                            );
                            return {
                                x: point.x,
                                y: d3.mean(window, d => d.y),
                                category: point.category
                            };
                        });

                        return smoothedPoints;
                    });

                    // Draw lines for each category
                    medianLines.forEach(points => {
                        const line = d3.line()
                            .x(d => xScale(d.x))
                            .y(d => yScale(d.y))
                            .curve(d3.curveBasis);

                        svg.append("path")
                            .datum(points)
                            .attr("fill", "none")
                            .attr("stroke", colorScale(points[0].category))
                            .attr("stroke-width", 2)
                            .attr("d", line)
                            .style("opacity", 1);
                    });

                    // Draw points
                    svg.selectAll("circle")
                        .data(chartData)
                        .enter()
                        .append("circle")
                        .attr("cx", d => xScale(d[xMetric]))
                        .attr("cy", d => yScale(d.Exam_Score))
                        .attr("r", 3)
                        .attr("fill", d => colorScale(d[variable]))
                        .attr("opacity", 0.05)
                        .on("mouseover", function(event, d) {
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .9);
                            tooltip.html(
                                `${variable.replace(/_/g, " ")}: ${d[variable]}<br/>` +
                                `${xMetric.replace(/_/g, " ")}: ${d[xMetric]}<br/>` +
                                `Exam Score: ${d.Exam_Score}`
                            )
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", function(d) {
                            tooltip.transition()
                                .duration(500)
                                .style("opacity", 0);
                        });

                    // Add axes
                    const xAxis = d3.axisBottom(xScale);
                    const yAxis = d3.axisLeft(yScale);

                    // Add X axis
                    svg.append("g")
                        .attr("transform", `translate(0,${height - margin.bottom})`)
                        .call(xAxis);

                    // Add Y axis
                    svg.append("g")
                        .attr("transform", `translate(${margin.left},0)`)
                        .call(yAxis);

                    // Add X axis label
                    svg.append("text")
                        .attr("class", "axis-label")
                        .attr("x", width / 2)
                        .attr("y", height - margin.bottom / 3)
                        .style("text-anchor", "middle")
                        .text(xMetric.replace(/_/g, " "));

                    // Add Y axis label
                    svg.append("text")
                        .attr("class", "axis-label")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -(height / 2))
                        .attr("y", margin.left / 2)
                        .style("text-anchor", "middle")
                        .text("Exam Score");

                    // Add chart title
                    svg.append("text")
                        .attr("class", "chart-title")
                        .attr("x", width / 2)
                        .attr("y", margin.top / 2)
                        .style("text-anchor", "middle")
                        .text(chart.title);

                    // Add legend with interactive elements
                    const legend = svg.append("g")
                        .attr("class", "legend")
                        .attr("transform", `translate(${width - margin.right + 20}, ${margin.top})`);

                    // Keep track of active categories (start with all active)
                    const activeCategories = new Set(categories);

                    // Create legend group for each item
                    const legendItems = legend.selectAll("g")
                        .data(categories)
                        .enter()
                        .append("g")
                        .attr("transform", (d, i) => `translate(0, ${i * 20})`)
                        .style("cursor", "pointer")
                        .on("click", function(event, category) {
                            // Toggle category
                            if (activeCategories.has(category)) {
                                activeCategories.delete(category);
                                d3.select(this).style("opacity", 0.5);
                                // Hide checkmark
                                d3.select(this).select(".checkmark").style("opacity", 0);
                            } else {
                                activeCategories.add(category);
                                d3.select(this).style("opacity", 1);
                                // Show checkmark
                                d3.select(this).select(".checkmark").style("opacity", 1);
                            }

                            // Update visibility of points
                            svg.selectAll("circle")
                                .style("display", d => activeCategories.has(d[variable]) ? null : "none");

                            // Update visibility of lines
                            svg.selectAll("path")
                                .style("display", function(d) {
                                    if (!d || d.length === 0) return "none";
                                    return activeCategories.has(d[0].category) ? null : "none";
                                });
                        });

                    // Add colored rectangles
                    legendItems.append("rect")
                        .attr("width", 12)
                        .attr("height", 12)
                        .attr("fill", d => colorScale(d));

                    // Add checkmark symbol
                    legendItems.append("text")
                        .attr("class", "checkmark")
                        .attr("x", 2)  // Center in the square
                        .attr("y", 10)
                        .style("font-size", "12px")
                        .style("fill", "white")  // Make checkmark white for better contrast
                        .style("font-weight", "bold")
                        .text("✓")
                        .style("opacity", 1); // Start with all checkmarks visible

                    // Add text labels
                    legendItems.append("text")
                        .attr("x", 20)
                        .attr("y", 10)
                        .text(d => d);

                    // Add hover effect
                    legendItems
                        .on("mouseover", function() {
                            d3.select(this)
                                .style("filter", "brightness(0.8)");
                        })
                        .on("mouseout", function() {
                            d3.select(this)
                                .style("filter", null);
                        });

                });
            };

            // Attach event listeners
            d3.selectAll("#xAxis, #genderFilter").on("change", updateVis);

            // Event listeners for variable selectors
            charts.forEach(chart => {
                const controls = d3.select(`#${chart.controlsId}`);
                const variableSelect = controls.select(".variableSelector");

                variableSelect.on("change", function() {
                    updateVis();
                });
            });

            // Initial visualization
            updateVis();
        }).catch(error => {
            console.error("Error loading or parsing data:", error);
        });
    </script>
</body>
</html>
